#include "db-tests.hpp"
#include "db.hpp"
#include <string>
#include <string.h>
#include <fstream>
#include <sstream>
#include "enclave_u.h" // Headers for untrusted part (autogenerated by edger8r)
#include <time.hpp>
#include <thread>
#include <assert.h>
using namespace std;

int test_null_ocalls(sgx_enclave_id_t eid) {

	unsigned long long start, end; 

	printf("Testing: null ecall for %d iterations\n", ECALL_TEST_LENGTH);
	start = RDTSC();
	for (int i = 0; i < ECALL_TEST_LENGTH; i++) {
		ecall_null_ecall(eid);
	}
	end = RDTSC();
	printf("Null ecall %llu cycles\n", (end - start)/ECALL_TEST_LENGTH);

	ecall_test_null_ocall(eid);
};

void thread_fn(void) {
	ecall_null_ecall(1);
}

int test_threads(sgx_enclave_id_t eid) {
	printf("Creating threads\n");
	thread t1(thread_fn);
	thread t2(thread_fn);
	thread t3(thread_fn);

	t1.join();
	t2.join();
	t3.join();
	printf("Joining threads\n");
	return 0;
}

int test_rankings(sgx_enclave_id_t eid) {
 	
	schema_t sc, sc_udata;
	std::string db_name("rankings-and-udata");
	std::string table_name("rankings");
	std::string udata_table_name("udata");
	int i, db_id, table_id, udata_table_id, join_table_id, ret; 
	join_condition_t c;
	char line[MAX_ROW_SIZE]; 
	char data[MAX_ROW_SIZE];
	uint8_t *row;
	sgx_status_t sgx_ret = SGX_ERROR_UNEXPECTED;

	sc.num_fields = 4;
	sc.offsets[0] = 0;
	sc.sizes[0] = 1;
	sc.types[0] = CHARACTER;
	sc.offsets[1] = 1;
	sc.sizes[1] = 255;
	sc.types[1] = TINYTEXT;
	sc.offsets[2] = 256;
	sc.sizes[2] = 4;
	sc.types[2] = INTEGER;
	sc.offsets[3] = 260;
	sc.sizes[3] = 4;
	sc.types[3] = INTEGER;
	sc.row_size = sc.offsets[sc.num_fields - 1] + sc.sizes[sc.num_fields - 1];

	//row = (uint8_t*)malloc(sc.row_size);
	row = (uint8_t*)malloc(MAX_ROW_SIZE);

	sgx_ret = ecall_create_db(eid, &ret, db_name.c_str(), db_name.length(), &db_id);
	if (sgx_ret || ret) {
		ERR("create db error:%d (sgx ret:%d)\n", ret, sgx_ret);
		return ret; 
	}

	sgx_ret = ecall_create_table(eid, &ret, db_id, table_name.c_str(), table_name.length(), &sc, &table_id);
	if (sgx_ret || ret) {
		ERR("create table error:%d (sgx ret:%d)\n", ret, sgx_ret);
		return ret; 
	}

	std::ifstream file("rankings.csv");

	row[0] = 'a';
	for(int i = 0; i < 360000; i++) { 
	//for(int i = 0; i < 10000; i++) { 

		memset(row, 'a', MAX_ROW_SIZE);
		file.getline(line, MAX_ROW_SIZE); //get the field

		std::istringstream ss(line);
		for(int j = 1; j < sc.num_fields; j++) {
			if(!ss.getline(data, MAX_ROW_SIZE, ',')) {
				ERR("something is wrong with data (skipping):%s\n", line);
				break;
			}
			if(sc.types[j] == INTEGER) {
				int d = 0;
				d = atoi(data);
				memcpy(&row[sc.offsets[j]], &d, 4);
			} else if (sc.types[j] == TINYTEXT) {
				strncpy((char*)&row[sc.offsets[j]], data, strlen(data) + 1);
			}
		}

		//DBG_ON(VERBOSE_INSERT, "insert row:%s\n", (char*)row); 
	
		sgx_ret = ecall_insert_row_dbg(eid, &ret, db_id, table_id, row);
		if (sgx_ret) {
			ERR("insert row:%d, err:%d (sgx ret:%d)\n", i, ret, sgx_ret);
			return ret; 
		}
		
	
	}

	ecall_flush_table(eid, &ret, db_id, table_id);
	printf("created rankings table\n");

	sc_udata.num_fields = 10;
	sc_udata.offsets[0] = 0;
	sc_udata.sizes[0] = 1;
	sc_udata.types[0] = CHARACTER;
	sc_udata.offsets[1] = 1;
	sc_udata.sizes[1] = 255;
	sc_udata.types[1] = TINYTEXT;
	sc_udata.offsets[2] = 256;
	sc_udata.sizes[2] = 255;
	sc_udata.types[2] = TINYTEXT;
	sc_udata.offsets[3] = 511;
	sc_udata.sizes[3] = 4;
	sc_udata.types[3] = INTEGER;
	sc_udata.offsets[4] = 515;
	sc_udata.sizes[4] = 4;
	sc_udata.types[4] = INTEGER;
	sc_udata.offsets[5] = 519;
	sc_udata.sizes[5] = 255;
	sc_udata.types[5] = TINYTEXT;
	sc_udata.offsets[6] = 774;
	sc_udata.sizes[6] = 255;
	sc_udata.types[6] = TINYTEXT;
	sc_udata.offsets[7] = 1029;
	sc_udata.sizes[7] = 255;
	sc_udata.types[7] = TINYTEXT;
	sc_udata.offsets[8] = 1284;
	sc_udata.sizes[8] = 255;
	sc_udata.types[8] = TINYTEXT;
	sc_udata.offsets[9] = 1539;
	sc_udata.sizes[9] = 4;
	sc_udata.types[9] = INTEGER;

	sc_udata.row_size = sc_udata.offsets[sc_udata.num_fields - 1] + sc_udata.sizes[sc_udata.num_fields - 1];

	sgx_ret = ecall_create_table(eid, &ret, db_id, udata_table_name.c_str(), udata_table_name.length(), &sc_udata, &udata_table_id);
	if (sgx_ret || ret) {
		ERR("create table error:%d (sgx ret:%d), table:%s\n", 
			ret, sgx_ret, udata_table_name.c_str());
		return ret; 
	}

	std::ifstream file2("uservisits.csv");

	row[0] = 'a';
	for(int i = 0; i < 350000; i++){//TODO temp really 350000
	//for(int i = 0; i < 10000; i++){//TODO temp really 350000
	
		memset(row, 'a', MAX_ROW_SIZE);
		file2.getline(line, MAX_ROW_SIZE);//get the field

		std::istringstream ss(line);

		for(int j = 1; j < sc_udata.num_fields; j++) {
			if(!ss.getline(data, MAX_ROW_SIZE, ',')){
				break;
			}
			if(sc_udata.types[j] == INTEGER) {
				int d = 0;
				d = atoi(data);
				memcpy(&row[sc_udata.offsets[j]], &d, 4);
			} else if (sc_udata.types[j] == TINYTEXT) {
				strncpy((char*)&row[sc_udata.offsets[j]], data, strlen(data) + 1);
			}
		}

		sgx_ret = ecall_insert_row_dbg(eid, &ret, db_id, udata_table_id, row);
		if (sgx_ret || ret) {
			ERR("insert row:%d into %s, err:%d (sgx ret:%d)\n", 
				i, udata_table_name.c_str(), ret, sgx_ret);
			return ret; 
		}

	}

	ecall_flush_table(eid, &ret, db_id, udata_table_id);
	printf("created uservisits table\n");

#if defined(TABLE_SCAN_TESTS)
	for (i = 0; i < 10; i++) {
		ecall_scan_table_dbg(eid, &ret, db_id, table_id);
	}

	for (i = 0; i < 10; i++) {
		ecall_scan_table_dbg(eid, &ret, db_id, udata_table_id);
	}
#endif

	/* Promote column tests */
	{
		int p_rankings_id;
		ecall_promote_table_dbg(eid, &ret, db_id, table_id, 1, &p_rankings_id);
		printf("promoted rankings table\n");
		ecall_print_table_dbg(eid, &ret, db_id, table_id, 0, 20);
		ecall_print_table_dbg(eid, &ret, db_id, p_rankings_id, 0, 20);
	}



	c.num_conditions = 1; 
	c.table_left = table_id; 
	c.table_right = udata_table_id; 
	c.fields_left[0] = 1;
	c.fields_right[0] = 2;

	sgx_ret = ecall_join(eid, &ret, db_id, &c, &join_table_id);
	if (sgx_ret || ret) {
		ERR("join failed, err:%d (sgx ret:%d)\n", 
			ret, sgx_ret);
		return ret; 
	}

	ecall_flush_table(eid, &ret, db_id, join_table_id);
	printf("joined successfully\n");
	return 0;

}

void assert_schemas_entries_same(schema_t sc1, schema_t sc2, int i, int j)
{
    assert(sc1.offsets[i] == sc2.offsets[j]);
    assert(sc1.types[i] == sc2.offsets[j]);
    assert(sc1.sizes[i] == sc2.sizes[j]);
}

int test_project_schema() {
    schema_t sc_old, sc_new;
    int *columns;
    sc_old.num_fields = 3; 

    sc_old.offsets[0] = 0;
    sc_old.types[0] = BOOLEAN;
    sc_old.sizes[0] = 1;

    sc_old.offsets[1] = 1;
    sc_old.types[1] = INTEGER;
    sc_old.sizes[1] = 4;

    sc_old.offsets[2] = 5;
    sc_old.types[2] = TINYTEXT;
    sc_old.sizes[2] = 10;

    sc_old.row_size = sc_old.sizes[0] + sc_old.sizes[1] + sc_old.sizes[2];

    // all columns
    columns = new int[3];
    columns[0] = 0; columns[1] = 1; columns[2] = 2;
    project_schema(&sc_old, columns, 3, &sc_new);
    assert(sc_new.row_size == sc_old.row_size);
    assert(sc_new.num_fields == 3);
    for(int i = 0; i < 3; i++)
    {
        assert_schemas_entries_same(sc_new, sc_old, i, i);
    }
    delete [] columns;

    // columns 0 and 2
    columns = new int[2];
    columns[0] = 0; columns[1] = 2;
    project_schema(&sc_old, columns, 2, &sc_new);
    assert(sc_new.row_size == sc_old.sizes[0] + sc_old.sizes[2]);
    assert(sc_new.num_fields == 2);

    assert_schemas_entries_same(sc_new, sc_old, 0, 0);
    assert_schemas_entries_same(sc_new, sc_old, 1, 2);
    
    // columns 0 and 1
    columns[1] = 1;
    project_schema(&sc_old, columns, 2, &sc_new);
    assert(sc_new.row_size == sc_old.sizes[0] + sc_old.sizes[1]);
    assert(sc_new.num_fields == 2);

    assert_schemas_entries_same(sc_new, sc_old, 0, 0);
    assert_schemas_entries_same(sc_new, sc_old, 1, 1);

    // columns 2 and 0
    columns[0] = 2; columns[1] = 0;
    project_schema(&sc_old, columns, 2, &sc_new);
    assert(sc_new.row_size == sc_old.sizes[2] + sc_old.sizes[0]);
    assert(sc_new.num_fields == 2);

    assert_schemas_entries_same(sc_new, sc_old, 0, 2);
    assert_schemas_entries_same(sc_new, sc_old, 1, 0);
}

void assert_schema_same_except_for_padding_at_end(schema_t sc1, schema_t sc2, int num_pad_bytes) {
    for(int i = 0; i < sc1.num_fields; i++) {
        assert_schemas_entries_same(sc1, sc2, i, i);
    }
    assert(sc2.num_fields == sc1.num_fields + 1);
    int padding_field_num = sc1.num_fields;
    assert(sc2.offsets[padding_field_num] == sc2.offsets[padding_field_num - 1] 
                                             + sc2.sizes[padding_field_num - 1]);
    assert(sc2.types[padding_field_num] == PADDING);
    assert(sc2.size[padding_field_num] == num_pad_bytes);
}

int test_pad_schema() {
    schema_t sc_old, sc_new;

    sc_old.offsets[0] = 0;
    sc_old.types[0] = INTEGER;
    sc_old.sizes[0] = 8;

    sc_old.offsets[1] = 1;
    sc_old.types[1] = TINYTEXT;
    sc_old.sizes[1] = 15;

    sc_old.offsets[2] = 5;
    sc_old.types[2] = BOOLEAN;
    sc_old.sizes[2] = 1;

    int num_pad_bytes_values[3] = {0, 4, 7};
    int num_pad_bytes;
    for(int i = 0; i < 3; i++)
    {
        num_pad_bytes = num_pad_bytes_values[i];
        pad_schema(sc_old, sc_new, num_pad_bytes);
        assert_schema_same_except_for_padding_at_end(sc_old, sc_new, num_pad_bytes);
    }
}


